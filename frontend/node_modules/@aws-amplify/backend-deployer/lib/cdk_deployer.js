import stream from 'stream';
import readline from 'readline';
import { AmplifyError, AmplifyUserError, CDKContextKey, } from '@aws-amplify/platform-core';
import { dirname } from 'path';
/**
 * Commands that can be invoked
 */
var InvokableCommand;
(function (InvokableCommand) {
    InvokableCommand["DEPLOY"] = "deploy";
    InvokableCommand["DESTROY"] = "destroy";
    InvokableCommand["SYNTH"] = "synth";
})(InvokableCommand || (InvokableCommand = {}));
/**
 * Invokes CDK command via execa
 */
export class CDKDeployer {
    cdkErrorMapper;
    backendLocator;
    packageManagerController;
    relativeCloudAssemblyLocation = '.amplify/artifacts/cdk.out';
    /**
     * Instantiates instance of CDKDeployer
     */
    constructor(cdkErrorMapper, backendLocator, packageManagerController) {
        this.cdkErrorMapper = cdkErrorMapper;
        this.backendLocator = backendLocator;
        this.packageManagerController = packageManagerController;
    }
    /**
     * Invokes cdk deploy command
     */
    deploy = async (backendId, deployProps) => {
        const cdkCommandArgs = [];
        if (backendId.type === 'sandbox') {
            cdkCommandArgs.push('--hotswap-fallback');
            cdkCommandArgs.push('--method=direct');
            if (deployProps?.secretLastUpdated) {
                cdkCommandArgs.push('--context', `secretLastUpdated=${deployProps.secretLastUpdated.getTime()}`);
            }
        }
        if (deployProps?.profile) {
            cdkCommandArgs.push('--profile', deployProps.profile);
        }
        // first synth with the backend definition but suppress any errors.
        // We want to show errors from the TS compiler rather than the ESBuild as
        // TS errors are more relevant (Library validations are type reliant).
        const startTime = Date.now();
        let synthError = undefined;
        try {
            await this.tryInvokeCdk(InvokableCommand.SYNTH, backendId, this.getAppCommand(), cdkCommandArgs.concat('--quiet') // don't print the CFN template to stdout
            );
        }
        catch (e) {
            synthError = e;
        }
        // CDK prints synth time in seconds rounded to 2 decimal places. Here we duplicate that behavior.
        const synthTimeSeconds = Math.floor((Date.now() - startTime) / 10) / 100;
        // then run type checks
        try {
            await this.invokeTsc(deployProps);
        }
        catch (typeError) {
            if (synthError &&
                AmplifyError.isAmplifyError(typeError) &&
                typeError.cause?.message.match(/Cannot find module '\$amplify\/env\/.*' or its corresponding type declarations/)) {
                // synth has failed and we don't have auto generated function environment definition files. This
                // resulted in the exception caught here, which is not very useful for the customers.
                // We instead throw the synth error for customers to fix what caused the synth to fail.
                throw synthError;
            }
            throw typeError;
        }
        // If somehow TSC was successful but synth wasn't, we now throw to surface the synth error
        if (synthError) {
            throw synthError;
        }
        // then deploy with the cloud assembly that was generated during synth
        const deployResult = await this.tryInvokeCdk(InvokableCommand.DEPLOY, backendId, this.relativeCloudAssemblyLocation, cdkCommandArgs);
        return {
            deploymentTimes: {
                synthesisTime: synthTimeSeconds,
                totalTime: synthTimeSeconds + (deployResult?.deploymentTimes?.totalTime || 0),
            },
        };
    };
    /**
     * Invokes cdk destroy command
     */
    destroy = async (backendId, destroyProps) => {
        const cdkCommandArgs = ['--force'];
        if (destroyProps?.profile) {
            cdkCommandArgs.push('--profile', destroyProps.profile);
        }
        return this.tryInvokeCdk(InvokableCommand.DESTROY, backendId, this.getAppCommand(), cdkCommandArgs);
    };
    /**
     * Wrapper for the child process executor. Helps in unit testing as node:test framework
     * doesn't have capabilities to mock exported functions like `execa` as of right now.
     */
    executeCommand = async (commandArgs, options = {
        redirectStdoutToStderr: false,
    }) => {
        // We let the stdout and stdin inherit and streamed to parent process but pipe
        // the stderr and use it to throw on failure. This is to prevent actual
        // actionable errors being hidden among the stdout. Moreover execa errors are
        // useless when calling CLIs unless you made execa calling error.
        let aggregatedStderr = '';
        const aggregatorStderrStream = new stream.Writable();
        aggregatorStderrStream._write = function (chunk, encoding, done) {
            aggregatedStderr += chunk;
            done();
        };
        const childProcess = this.packageManagerController.runWithPackageManager(commandArgs, process.cwd(), {
            stdin: 'inherit',
            stdout: 'pipe',
            stderr: 'pipe',
            // Piping the output by default strips off the color. This is a workaround to
            // preserve the color being piped to parent process.
            extendEnv: true,
            env: { FORCE_COLOR: '1' },
        });
        childProcess.stderr?.pipe(aggregatorStderrStream);
        if (options?.redirectStdoutToStderr) {
            childProcess.stdout?.pipe(aggregatorStderrStream);
        }
        else {
            childProcess.stdout?.pipe(process.stdout);
        }
        const cdkOutput = { deploymentTimes: {} };
        if (childProcess.stdout) {
            await this.populateCDKOutputFromStdout(cdkOutput, childProcess.stdout);
        }
        try {
            await childProcess;
            return cdkOutput;
        }
        catch (error) {
            // swallow execa error if the cdk cli ran and produced some stderr.
            // Most of the time this error is noise(basically child exited with exit code...)
            // bubbling this up to customers add confusion (Customers don't need to know we are running IPC calls
            // and their exit codes printed while sandbox continue to run). Hence we explicitly don't pass error in the cause
            // rather throw the entire stderr for clients to figure out what to do with it.
            // However if the cdk process didn't run or produced no output, then we have nothing to go on with. So we throw
            // this error to aid in some debugging.
            if (aggregatedStderr.trim()) {
                // eslint-disable-next-line amplify-backend-rules/prefer-amplify-errors
                throw new Error(aggregatedStderr);
            }
            else {
                throw error;
            }
        }
    };
    getAppCommand = () => this.packageManagerController.getCommand([
        'tsx',
        this.backendLocator.locate(),
    ]);
    invokeTsc = async (deployProps) => {
        if (!deployProps?.validateAppSources) {
            return;
        }
        try {
            await this.executeCommand([
                'tsc',
                '--showConfig',
                '--project',
                dirname(this.backendLocator.locate()),
            ], { redirectStdoutToStderr: true } // TSC prints errors to stdout by default
            );
        }
        catch (error) {
            // If we cannot load ts config, turn off type checking
            return;
        }
        try {
            await this.executeCommand([
                'tsc',
                '--noEmit',
                '--skipLibCheck',
                // pointing the project arg to the amplify backend directory will use the tsconfig present in that directory
                '--project',
                dirname(this.backendLocator.locate()),
            ], { redirectStdoutToStderr: true } // TSC prints errors to stdout by default
            );
        }
        catch (err) {
            throw new AmplifyUserError('SyntaxError', {
                message: 'TypeScript validation check failed.',
                resolution: 'Fix the syntax and type errors in your backend definition.',
            }, err instanceof Error ? err : undefined);
        }
    };
    /**
     * calls invokeCDK and wrap it in a try catch
     */
    tryInvokeCdk = async (invokableCommand, backendId, appArgument, additionalArguments) => {
        try {
            return await this.invokeCdk(invokableCommand, backendId, appArgument, additionalArguments);
        }
        catch (err) {
            throw this.cdkErrorMapper.getAmplifyError(err);
        }
    };
    /**
     * Executes a CDK command
     */
    invokeCdk = async (invokableCommand, backendId, appArgument, additionalArguments) => {
        // Basic args
        const cdkCommandArgs = [
            'cdk',
            invokableCommand.toString(),
            // This is unfortunate. CDK writes everything to stderr without `--ci` flag and we need to differentiate between the two.
            // See https://github.com/aws/aws-cdk/issues/7717 for more details.
            '--ci',
            '--app',
            appArgument,
            '--all',
            '--output',
            this.relativeCloudAssemblyLocation,
        ];
        // Add context information if available
        cdkCommandArgs.push('--context', `${CDKContextKey.BACKEND_NAMESPACE}=${backendId.namespace}`, '--context', `${CDKContextKey.BACKEND_NAME}=${backendId.name}`);
        if (backendId.type !== 'sandbox') {
            cdkCommandArgs.push('--require-approval', 'never');
        }
        cdkCommandArgs.push('--context', `${CDKContextKey.DEPLOYMENT_TYPE}=${backendId.type}`);
        if (additionalArguments) {
            cdkCommandArgs.push(...additionalArguments);
        }
        return await this.executeCommand(cdkCommandArgs);
    };
    populateCDKOutputFromStdout = async (output, stdout) => {
        const regexTotalTime = /✨ {2}Total time: (\d*\.*\d*)s.*/;
        const regexSynthTime = /✨ {2}Synthesis time: (\d*\.*\d*)s/;
        const reader = readline.createInterface(stdout);
        for await (const line of reader) {
            if (line.includes('✨')) {
                // Good chance that it contains timing information
                const totalTime = line.match(regexTotalTime);
                if (totalTime && totalTime.length > 1 && !isNaN(+totalTime[1])) {
                    output.deploymentTimes.totalTime = +totalTime[1];
                }
                const synthTime = line.match(regexSynthTime);
                if (synthTime && synthTime.length > 1 && !isNaN(+synthTime[1])) {
                    output.deploymentTimes.synthesisTime = +synthTime[1];
                }
            }
        }
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2RrX2RlcGxveWVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2Nka19kZXBsb3llci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLE1BQU0sTUFBTSxRQUFRLENBQUM7QUFDNUIsT0FBTyxRQUFRLE1BQU0sVUFBVSxDQUFDO0FBYWhDLE9BQU8sRUFDTCxZQUFZLEVBQ1osZ0JBQWdCLEVBRWhCLGFBQWEsR0FDZCxNQUFNLDRCQUE0QixDQUFDO0FBQ3BDLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFFL0I7O0dBRUc7QUFDSCxJQUFLLGdCQUlKO0FBSkQsV0FBSyxnQkFBZ0I7SUFDbkIscUNBQWlCLENBQUE7SUFDakIsdUNBQW1CLENBQUE7SUFDbkIsbUNBQWUsQ0FBQTtBQUNqQixDQUFDLEVBSkksZ0JBQWdCLEtBQWhCLGdCQUFnQixRQUlwQjtBQUVEOztHQUVHO0FBQ0gsTUFBTSxPQUFPLFdBQVc7SUFNSDtJQUNBO0lBQ0E7SUFQRiw2QkFBNkIsR0FBRyw0QkFBNEIsQ0FBQztJQUM5RTs7T0FFRztJQUNILFlBQ21CLGNBQThCLEVBQzlCLGNBQThCLEVBQzlCLHdCQUFrRDtRQUZsRCxtQkFBYyxHQUFkLGNBQWMsQ0FBZ0I7UUFDOUIsbUJBQWMsR0FBZCxjQUFjLENBQWdCO1FBQzlCLDZCQUF3QixHQUF4Qix3QkFBd0IsQ0FBMEI7SUFDbEUsQ0FBQztJQUNKOztPQUVHO0lBQ0gsTUFBTSxHQUFHLEtBQUssRUFBRSxTQUE0QixFQUFFLFdBQXlCLEVBQUUsRUFBRTtRQUN6RSxNQUFNLGNBQWMsR0FBYSxFQUFFLENBQUM7UUFDcEMsSUFBSSxTQUFTLENBQUMsSUFBSSxLQUFLLFNBQVMsRUFBRTtZQUNoQyxjQUFjLENBQUMsSUFBSSxDQUFDLG9CQUFvQixDQUFDLENBQUM7WUFDMUMsY0FBYyxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO1lBQ3ZDLElBQUksV0FBVyxFQUFFLGlCQUFpQixF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R0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLGNBQWMsQ0FBQyxDQUFDO2dCQUM3QyxJQUFJLFNBQVMsSUFBSSxTQUFTLENBQUMsTUFBTSxHQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFO29CQUM5RCxNQUFNLENBQUMsZUFBZSxDQUFDLGFBQWEsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztpQkFDdEQ7YUFDRjtTQUNGO0lBQ0gsQ0FBQyxDQUFDO0NBQ0giLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgc3RyZWFtIGZyb20gJ3N0cmVhbSc7XG5pbXBvcnQgcmVhZGxpbmUgZnJvbSAncmVhZGxpbmUnO1xuaW1wb3J0IHtcbiAgQmFja2VuZERlcGxveWVyLFxuICBEZXBsb3lQcm9wcyxcbiAgRGVwbG95UmVzdWx0LFxuICBEZXN0cm95UHJvcHMsXG4gIERlc3Ryb3lSZXN1bHQsXG59IGZyb20gJy4vY2RrX2RlcGxveWVyX3NpbmdsZXRvbl9mYWN0b3J5LmpzJztcbmltcG9ydCB7IENES0RlcGxveW1lbnRFcnJvciwgQ2RrRXJyb3JNYXBwZXIgfSBmcm9tICcuL2Nka19lcnJvcl9tYXBwZXIuanMnO1xuaW1wb3J0IHtcbiAgQmFja2VuZElkZW50aWZpZXIsXG4gIHR5cGUgUGFja2FnZU1hbmFnZXJDb250cm9sbGVyLFxufSBmcm9tICdAYXdzLWFtcGxpZnkvcGx1Z2luLXR5cGVzJztcbmltcG9ydCB7XG4gIEFtcGxpZnlFcnJvcixcbiAgQW1wbGlmeVVzZXJFcnJvcixcbiAgQmFja2VuZExvY2F0b3IsXG4gIENES0NvbnRleHRLZXksXG59IGZyb20gJ0Bhd3MtYW1wbGlmeS9wbGF0Zm9ybS1jb3JlJztcbmltcG9ydCB7IGRpcm5hbWUgfSBmcm9tICdwYXRoJztcblxuLyoqXG4gKiBDb21tYW5kcyB0aGF0IGNhbiBiZSBpbnZva2VkXG4gKi9cbmVudW0gSW52b2thYmxlQ29tbWFuZCB7XG4gIERFUExPWSA9ICdkZXBsb3knLFxuICBERVNUUk9ZID0gJ2Rlc3Ryb3knLFxuICBTWU5USCA9ICdzeW50aCcsXG59XG5cbi8qKlxuICogSW52b2tlcyBDREsgY29tbWFuZCB2aWEgZXhlY2FcbiAqL1xuZXhwb3J0IGNsYXNzIENES0RlcGxveWVyIGltcGxlbWVudHMgQmFja2VuZERlcGxveWVyIHtcbiAgcHJpdmF0ZSByZWFkb25seSByZWxhdGl2ZUNsb3VkQXNzZW1ibHlMb2NhdGlvbiA9ICcuYW1wbGlmeS9hcnRpZmFjdHMvY2RrLm91dCc7XG4gIC8qKlxuICAgKiBJbnN0YW50aWF0ZXMgaW5zdGFuY2Ugb2YgQ0RLRGVwbG95ZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgY2RrRXJyb3JNYXBwZXI6IENka0Vycm9yTWFwcGVyLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgYmFja2VuZExvY2F0b3I6IEJhY2tlbmRMb2NhdG9yLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgcGFja2FnZU1hbmFnZXJDb250cm9sbGVyOiBQYWNrYWdlTWFuYWdlckNvbnRyb2xsZXJcbiAgKSB7fVxuICAvKipcbiAgICogSW52b2tlcyBjZGsgZGVwbG95IGNvbW1hbmRcbiAgICovXG4gIGRlcGxveSA9IGFzeW5jIChiYWNrZW5kSWQ6IEJhY2tlbmRJZGVudGlmaWVyLCBkZXBsb3lQcm9wcz86IERlcGxveVByb3BzKSA9PiB7XG4gICAgY29uc3QgY2RrQ29tbWFuZEFyZ3M6IHN0cmluZ1tdID0gW107XG4gICAgaWYgKGJhY2tlbmRJZC50eXBlID09PSAnc2FuZGJveCcpIHtcbiAgICAgIGNka0NvbW1hbmRBcmdzLnB1c2goJy0taG90c3dhcC1mYWxsYmFjaycpO1xuICAgICAgY2RrQ29tbWFuZEFyZ3MucHVzaCgnLS1tZXRob2Q9ZGlyZWN0Jyk7XG4gICAgICBpZiAoZGVwbG95UHJvcHM/LnNlY3JldExhc3RVcGRhdGVkKSB7XG4gICAgICAgIGNka0NvbW1hbmRBcmdzLnB1c2goXG4gICAgICAgICAgJy0tY29udGV4dCcsXG4gICAgICAgICAgYHNlY3JldExhc3RVcGRhdGVkPSR7ZGVwbG95UHJvcHMuc2VjcmV0TGFzdFVwZGF0ZWQuZ2V0VGltZSgpfWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZGVwbG95UHJvcHM/LnByb2ZpbGUpIHtcbiAgICAgIGNka0NvbW1hbmRBcmdzLnB1c2goJy0tcHJvZmlsZScsIGRlcGxveVByb3BzLnByb2ZpbGUpO1xuICAgIH1cblxuICAgIC8vIGZpcnN0IHN5bnRoIHdpdGggdGhlIGJhY2tlbmQgZGVmaW5pdGlvbiBidXQgc3VwcHJlc3MgYW55IGVycm9ycy5cbiAgICAvLyBXZSB3YW50IHRvIHNob3cgZXJyb3JzIGZyb20gdGhlIFRTIGNvbXBpbGVyIHJhdGhlciB0aGFuIHRoZSBFU0J1aWxkIGFzXG4gICAgLy8gVFMgZXJyb3JzIGFyZSBtb3JlIHJlbGV2YW50IChMaWJyYXJ5IHZhbGlkYXRpb25zIGFyZSB0eXBlIHJlbGlhbnQpLlxuICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgbGV0IHN5bnRoRXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMudHJ5SW52b2tlQ2RrKFxuICAgICAgICBJbnZva2FibGVDb21tYW5kLlNZTlRILFxuICAgICAgICBiYWNrZW5kSWQsXG4gICAgICAgIHRoaXMuZ2V0QXBwQ29tbWFuZCgpLFxuICAgICAgICBjZGtDb21tYW5kQXJncy5jb25jYXQoJy0tcXVpZXQnKSAvLyBkb24ndCBwcmludCB0aGUgQ0ZOIHRlbXBsYXRlIHRvIHN0ZG91dFxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBzeW50aEVycm9yID0gZTtcbiAgICB9XG4gICAgLy8gQ0RLIHByaW50cyBzeW50aCB0aW1lIGluIHNlY29uZHMgcm91bmRlZCB0byAyIGRlY2ltYWwgcGxhY2VzLiBIZXJlIHdlIGR1cGxpY2F0ZSB0aGF0IGJlaGF2aW9yLlxuICAgIGNvbnN0IHN5bnRoVGltZVNlY29uZHMgPSBNYXRoLmZsb29yKChEYXRlLm5vdygpIC0gc3RhcnRUaW1lKSAvIDEwKSAvIDEwMDtcblxuICAgIC8vIHRoZW4gcnVuIHR5cGUgY2hlY2tzXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuaW52b2tlVHNjKGRlcGxveVByb3BzKTtcbiAgICB9IGNhdGNoICh0eXBlRXJyb3I6IHVua25vd24pIHtcbiAgICAgIGlmIChcbiAgICAgICAgc3ludGhFcnJvciAmJlxuICAgICAgICBBbXBsaWZ5RXJyb3IuaXNBbXBsaWZ5RXJyb3IodHlwZUVycm9yKSAmJlxuICAgICAgICB0eXBlRXJyb3IuY2F1c2U/Lm1lc3NhZ2UubWF0Y2goXG4gICAgICAgICAgL0Nhbm5vdCBmaW5kIG1vZHVsZSAnXFwkYW1wbGlmeVxcL2VudlxcLy4qJyBvciBpdHMgY29ycmVzcG9uZGluZyB0eXBlIGRlY2xhcmF0aW9ucy9cbiAgICAgICAgKVxuICAgICAgKSB7XG4gICAgICAgIC8vIHN5bnRoIGhhcyBmYWlsZWQgYW5kIHdlIGRvbid0IGhhdmUgYXV0byBnZW5lcmF0ZWQgZnVuY3Rpb24gZW52aXJvbm1lbnQgZGVmaW5pdGlvbiBmaWxlcy4gVGhpc1xuICAgICAgICAvLyByZXN1bHRlZCBpbiB0aGUgZXhjZXB0aW9uIGNhdWdodCBoZXJlLCB3aGljaCBpcyBub3QgdmVyeSB1c2VmdWwgZm9yIHRoZSBjdXN0b21lcnMuXG4gICAgICAgIC8vIFdlIGluc3RlYWQgdGhyb3cgdGhlIHN5bnRoIGVycm9yIGZvciBjdXN0b21lcnMgdG8gZml4IHdoYXQgY2F1c2VkIHRoZSBzeW50aCB0byBmYWlsLlxuICAgICAgICB0aHJvdyBzeW50aEVycm9yO1xuICAgICAgfVxuICAgICAgdGhyb3cgdHlwZUVycm9yO1xuICAgIH1cblxuICAgIC8vIElmIHNvbWVob3cgVFNDIHdhcyBzdWNjZXNzZnVsIGJ1dCBzeW50aCB3YXNuJ3QsIHdlIG5vdyB0aHJvdyB0byBzdXJmYWNlIHRoZSBzeW50aCBlcnJvclxuICAgIGlmIChzeW50aEVycm9yKSB7XG4gICAgICB0aHJvdyBzeW50aEVycm9yO1xuICAgIH1cblxuICAgIC8vIHRoZW4gZGVwbG95IHdpdGggdGhlIGNsb3VkIGFzc2VtYmx5IHRoYXQgd2FzIGdlbmVyYXRlZCBkdXJpbmcgc3ludGhcbiAgICBjb25zdCBkZXBsb3lSZXN1bHQgPSBhd2FpdCB0aGlzLnRyeUludm9rZUNkayhcbiAgICAgIEludm9rYWJsZUNvbW1hbmQuREVQTE9ZLFxuICAgICAgYmFja2VuZElkLFxuICAgICAgdGhpcy5yZWxhdGl2ZUNsb3VkQXNzZW1ibHlMb2NhdGlvbixcbiAgICAgIGNka0NvbW1hbmRBcmdzXG4gICAgKTtcblxuICAgIHJldHVybiB7XG4gICAgICBkZXBsb3ltZW50VGltZXM6IHtcbiAgICAgICAgc3ludGhlc2lzVGltZTogc3ludGhUaW1lU2Vjb25kcyxcbiAgICAgICAgdG90YWxUaW1lOlxuICAgICAgICAgIHN5bnRoVGltZVNlY29uZHMgKyAoZGVwbG95UmVzdWx0Py5kZXBsb3ltZW50VGltZXM/LnRvdGFsVGltZSB8fCAwKSxcbiAgICAgIH0sXG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogSW52b2tlcyBjZGsgZGVzdHJveSBjb21tYW5kXG4gICAqL1xuICBkZXN0cm95ID0gYXN5bmMgKFxuICAgIGJhY2tlbmRJZDogQmFja2VuZElkZW50aWZpZXIsXG4gICAgZGVzdHJveVByb3BzPzogRGVzdHJveVByb3BzXG4gICkgPT4ge1xuICAgIGNvbnN0IGNka0NvbW1hbmRBcmdzOiBzdHJpbmdbXSA9IFsnLS1mb3JjZSddO1xuICAgIGlmIChkZXN0cm95UHJvcHM/LnByb2ZpbGUpIHtcbiAgICAgIGNka0NvbW1hbmRBcmdzLnB1c2goJy0tcHJvZmlsZScsIGRlc3Ryb3lQcm9wcy5wcm9maWxlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudHJ5SW52b2tlQ2RrKFxuICAgICAgSW52b2thYmxlQ29tbWFuZC5ERVNUUk9ZLFxuICAgICAgYmFja2VuZElkLFxuICAgICAgdGhpcy5nZXRBcHBDb21tYW5kKCksXG4gICAgICBjZGtDb21tYW5kQXJnc1xuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdyYXBwZXIgZm9yIHRoZSBjaGlsZCBwcm9jZXNzIGV4ZWN1dG9yLiBIZWxwcyBpbiB1bml0IHRlc3RpbmcgYXMgbm9kZTp0ZXN0IGZyYW1ld29ya1xuICAgKiBkb2Vzbid0IGhhdmUgY2FwYWJpbGl0aWVzIHRvIG1vY2sgZXhwb3J0ZWQgZnVuY3Rpb25zIGxpa2UgYGV4ZWNhYCBhcyBvZiByaWdodCBub3cuXG4gICAqL1xuICBleGVjdXRlQ29tbWFuZCA9IGFzeW5jIChcbiAgICBjb21tYW5kQXJnczogc3RyaW5nW10sXG4gICAgb3B0aW9uczogeyByZWRpcmVjdFN0ZG91dFRvU3RkZXJyOiBib29sZWFuIH0gPSB7XG4gICAgICByZWRpcmVjdFN0ZG91dFRvU3RkZXJyOiBmYWxzZSxcbiAgICB9XG4gICkgPT4ge1xuICAgIC8vIFdlIGxldCB0aGUgc3Rkb3V0IGFuZCBzdGRpbiBpbmhlcml0IGFuZCBzdHJlYW1lZCB0byBwYXJlbnQgcHJvY2VzcyBidXQgcGlwZVxuICAgIC8vIHRoZSBzdGRlcnIgYW5kIHVzZSBpdCB0byB0aHJvdyBvbiBmYWlsdXJlLiBUaGlzIGlzIHRvIHByZXZlbnQgYWN0dWFsXG4gICAgLy8gYWN0aW9uYWJsZSBlcnJvcnMgYmVpbmcgaGlkZGVuIGFtb25nIHRoZSBzdGRvdXQuIE1vcmVvdmVyIGV4ZWNhIGVycm9ycyBhcmVcbiAgICAvLyB1c2VsZXNzIHdoZW4gY2FsbGluZyBDTElzIHVubGVzcyB5b3UgbWFkZSBleGVjYSBjYWxsaW5nIGVycm9yLlxuICAgIGxldCBhZ2dyZWdhdGVkU3RkZXJyID0gJyc7XG4gICAgY29uc3QgYWdncmVnYXRvclN0ZGVyclN0cmVhbSA9IG5ldyBzdHJlYW0uV3JpdGFibGUoKTtcbiAgICBhZ2dyZWdhdG9yU3RkZXJyU3RyZWFtLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGRvbmUpIHtcbiAgICAgIGFnZ3JlZ2F0ZWRTdGRlcnIgKz0gY2h1bms7XG4gICAgICBkb25lKCk7XG4gICAgfTtcbiAgICBjb25zdCBjaGlsZFByb2Nlc3MgPSB0aGlzLnBhY2thZ2VNYW5hZ2VyQ29udHJvbGxlci5ydW5XaXRoUGFja2FnZU1hbmFnZXIoXG4gICAgICBjb21tYW5kQXJncyxcbiAgICAgIHByb2Nlc3MuY3dkKCksXG4gICAgICB7XG4gICAgICAgIHN0ZGluOiAnaW5oZXJpdCcsXG4gICAgICAgIHN0ZG91dDogJ3BpcGUnLFxuICAgICAgICBzdGRlcnI6ICdwaXBlJyxcbiAgICAgICAgLy8gUGlwaW5nIHRoZSBvdXRwdXQgYnkgZGVmYXVsdCBzdHJpcHMgb2ZmIHRoZSBjb2xvci4gVGhpcyBpcyBhIHdvcmthcm91bmQgdG9cbiAgICAgICAgLy8gcHJlc2VydmUgdGhlIGNvbG9yIGJlaW5nIHBpcGVkIHRvIHBhcmVudCBwcm9jZXNzLlxuICAgICAgICBleHRlbmRFbnY6IHRydWUsXG4gICAgICAgIGVudjogeyBGT1JDRV9DT0xPUjogJzEnIH0sXG4gICAgICB9XG4gICAgKTtcblxuICAgIGNoaWxkUHJvY2Vzcy5zdGRlcnI/LnBpcGUoYWdncmVnYXRvclN0ZGVyclN0cmVhbSk7XG5cbiAgICBpZiAob3B0aW9ucz8ucmVkaXJlY3RTdGRvdXRUb1N0ZGVycikge1xuICAgICAgY2hpbGRQcm9jZXNzLnN0ZG91dD8ucGlwZShhZ2dyZWdhdG9yU3RkZXJyU3RyZWFtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hpbGRQcm9jZXNzLnN0ZG91dD8ucGlwZShwcm9jZXNzLnN0ZG91dCk7XG4gICAgfVxuXG4gICAgY29uc3QgY2RrT3V0cHV0ID0geyBkZXBsb3ltZW50VGltZXM6IHt9IH07XG4gICAgaWYgKGNoaWxkUHJvY2Vzcy5zdGRvdXQpIHtcbiAgICAgIGF3YWl0IHRoaXMucG9wdWxhdGVDREtPdXRwdXRGcm9tU3Rkb3V0KGNka091dHB1dCwgY2hpbGRQcm9jZXNzLnN0ZG91dCk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGNoaWxkUHJvY2VzcztcbiAgICAgIHJldHVybiBjZGtPdXRwdXQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIHN3YWxsb3cgZXhlY2EgZXJyb3IgaWYgdGhlIGNkayBjbGkgcmFuIGFuZCBwcm9kdWNlZCBzb21lIHN0ZGVyci5cbiAgICAgIC8vIE1vc3Qgb2YgdGhlIHRpbWUgdGhpcyBlcnJvciBpcyBub2lzZShiYXNpY2FsbHkgY2hpbGQgZXhpdGVkIHdpdGggZXhpdCBjb2RlLi4uKVxuICAgICAgLy8gYnViYmxpbmcgdGhpcyB1cCB0byBjdXN0b21lcnMgYWRkIGNvbmZ1c2lvbiAoQ3VzdG9tZXJzIGRvbid0IG5lZWQgdG8ga25vdyB3ZSBhcmUgcnVubmluZyBJUEMgY2FsbHNcbiAgICAgIC8vIGFuZCB0aGVpciBleGl0IGNvZGVzIHByaW50ZWQgd2hpbGUgc2FuZGJveCBjb250aW51ZSB0byBydW4pLiBIZW5jZSB3ZSBleHBsaWNpdGx5IGRvbid0IHBhc3MgZXJyb3IgaW4gdGhlIGNhdXNlXG4gICAgICAvLyByYXRoZXIgdGhyb3cgdGhlIGVudGlyZSBzdGRlcnIgZm9yIGNsaWVudHMgdG8gZmlndXJlIG91dCB3aGF0IHRvIGRvIHdpdGggaXQuXG4gICAgICAvLyBIb3dldmVyIGlmIHRoZSBjZGsgcHJvY2VzcyBkaWRuJ3QgcnVuIG9yIHByb2R1Y2VkIG5vIG91dHB1dCwgdGhlbiB3ZSBoYXZlIG5vdGhpbmcgdG8gZ28gb24gd2l0aC4gU28gd2UgdGhyb3dcbiAgICAgIC8vIHRoaXMgZXJyb3IgdG8gYWlkIGluIHNvbWUgZGVidWdnaW5nLlxuICAgICAgaWYgKGFnZ3JlZ2F0ZWRTdGRlcnIudHJpbSgpKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBhbXBsaWZ5LWJhY2tlbmQtcnVsZXMvcHJlZmVyLWFtcGxpZnktZXJyb3JzXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihhZ2dyZWdhdGVkU3RkZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBwcml2YXRlIGdldEFwcENvbW1hbmQgPSAoKSA9PlxuICAgIHRoaXMucGFja2FnZU1hbmFnZXJDb250cm9sbGVyLmdldENvbW1hbmQoW1xuICAgICAgJ3RzeCcsXG4gICAgICB0aGlzLmJhY2tlbmRMb2NhdG9yLmxvY2F0ZSgpLFxuICAgIF0pO1xuXG4gIHByaXZhdGUgaW52b2tlVHNjID0gYXN5bmMgKGRlcGxveVByb3BzPzogRGVwbG95UHJvcHMpID0+IHtcbiAgICBpZiAoIWRlcGxveVByb3BzPy52YWxpZGF0ZUFwcFNvdXJjZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuZXhlY3V0ZUNvbW1hbmQoXG4gICAgICAgIFtcbiAgICAgICAgICAndHNjJyxcbiAgICAgICAgICAnLS1zaG93Q29uZmlnJyxcbiAgICAgICAgICAnLS1wcm9qZWN0JyxcbiAgICAgICAgICBkaXJuYW1lKHRoaXMuYmFja2VuZExvY2F0b3IubG9jYXRlKCkpLFxuICAgICAgICBdLFxuICAgICAgICB7IHJlZGlyZWN0U3Rkb3V0VG9TdGRlcnI6IHRydWUgfSAvLyBUU0MgcHJpbnRzIGVycm9ycyB0byBzdGRvdXQgYnkgZGVmYXVsdFxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gSWYgd2UgY2Fubm90IGxvYWQgdHMgY29uZmlnLCB0dXJuIG9mZiB0eXBlIGNoZWNraW5nXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLmV4ZWN1dGVDb21tYW5kKFxuICAgICAgICBbXG4gICAgICAgICAgJ3RzYycsXG4gICAgICAgICAgJy0tbm9FbWl0JyxcbiAgICAgICAgICAnLS1za2lwTGliQ2hlY2snLFxuICAgICAgICAgIC8vIHBvaW50aW5nIHRoZSBwcm9qZWN0IGFyZyB0byB0aGUgYW1wbGlmeSBiYWNrZW5kIGRpcmVjdG9yeSB3aWxsIHVzZSB0aGUgdHNjb25maWcgcHJlc2VudCBpbiB0aGF0IGRpcmVjdG9yeVxuICAgICAgICAgICctLXByb2plY3QnLFxuICAgICAgICAgIGRpcm5hbWUodGhpcy5iYWNrZW5kTG9jYXRvci5sb2NhdGUoKSksXG4gICAgICAgIF0sXG4gICAgICAgIHsgcmVkaXJlY3RTdGRvdXRUb1N0ZGVycjogdHJ1ZSB9IC8vIFRTQyBwcmludHMgZXJyb3JzIHRvIHN0ZG91dCBieSBkZWZhdWx0XG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgbmV3IEFtcGxpZnlVc2VyRXJyb3I8Q0RLRGVwbG95bWVudEVycm9yPihcbiAgICAgICAgJ1N5bnRheEVycm9yJyxcbiAgICAgICAge1xuICAgICAgICAgIG1lc3NhZ2U6ICdUeXBlU2NyaXB0IHZhbGlkYXRpb24gY2hlY2sgZmFpbGVkLicsXG4gICAgICAgICAgcmVzb2x1dGlvbjpcbiAgICAgICAgICAgICdGaXggdGhlIHN5bnRheCBhbmQgdHlwZSBlcnJvcnMgaW4geW91ciBiYWNrZW5kIGRlZmluaXRpb24uJyxcbiAgICAgICAgfSxcbiAgICAgICAgZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIgOiB1bmRlZmluZWRcbiAgICAgICk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBjYWxscyBpbnZva2VDREsgYW5kIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2hcbiAgICovXG4gIHByaXZhdGUgdHJ5SW52b2tlQ2RrID0gYXN5bmMgKFxuICAgIGludm9rYWJsZUNvbW1hbmQ6IEludm9rYWJsZUNvbW1hbmQsXG4gICAgYmFja2VuZElkOiBCYWNrZW5kSWRlbnRpZmllcixcbiAgICBhcHBBcmd1bWVudDogc3RyaW5nLFxuICAgIGFkZGl0aW9uYWxBcmd1bWVudHM/OiBzdHJpbmdbXVxuICApOiBQcm9taXNlPERlcGxveVJlc3VsdCB8IERlc3Ryb3lSZXN1bHQ+ID0+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuaW52b2tlQ2RrKFxuICAgICAgICBpbnZva2FibGVDb21tYW5kLFxuICAgICAgICBiYWNrZW5kSWQsXG4gICAgICAgIGFwcEFyZ3VtZW50LFxuICAgICAgICBhZGRpdGlvbmFsQXJndW1lbnRzXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgdGhpcy5jZGtFcnJvck1hcHBlci5nZXRBbXBsaWZ5RXJyb3IoZXJyIGFzIEVycm9yKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIGEgQ0RLIGNvbW1hbmRcbiAgICovXG4gIHByaXZhdGUgaW52b2tlQ2RrID0gYXN5bmMgKFxuICAgIGludm9rYWJsZUNvbW1hbmQ6IEludm9rYWJsZUNvbW1hbmQsXG4gICAgYmFja2VuZElkOiBCYWNrZW5kSWRlbnRpZmllcixcbiAgICBhcHBBcmd1bWVudDogc3RyaW5nLFxuICAgIGFkZGl0aW9uYWxBcmd1bWVudHM/OiBzdHJpbmdbXVxuICApOiBQcm9taXNlPERlcGxveVJlc3VsdCB8IERlc3Ryb3lSZXN1bHQ+ID0+IHtcbiAgICAvLyBCYXNpYyBhcmdzXG4gICAgY29uc3QgY2RrQ29tbWFuZEFyZ3MgPSBbXG4gICAgICAnY2RrJyxcbiAgICAgIGludm9rYWJsZUNvbW1hbmQudG9TdHJpbmcoKSxcbiAgICAgIC8vIFRoaXMgaXMgdW5mb3J0dW5hdGUuIENESyB3cml0ZXMgZXZlcnl0aGluZyB0byBzdGRlcnIgd2l0aG91dCBgLS1jaWAgZmxhZyBhbmQgd2UgbmVlZCB0byBkaWZmZXJlbnRpYXRlIGJldHdlZW4gdGhlIHR3by5cbiAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vYXdzL2F3cy1jZGsvaXNzdWVzLzc3MTcgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICctLWNpJyxcbiAgICAgICctLWFwcCcsXG4gICAgICBhcHBBcmd1bWVudCxcbiAgICAgICctLWFsbCcsXG4gICAgICAnLS1vdXRwdXQnLFxuICAgICAgdGhpcy5yZWxhdGl2ZUNsb3VkQXNzZW1ibHlMb2NhdGlvbixcbiAgICBdO1xuXG4gICAgLy8gQWRkIGNvbnRleHQgaW5mb3JtYXRpb24gaWYgYXZhaWxhYmxlXG4gICAgY2RrQ29tbWFuZEFyZ3MucHVzaChcbiAgICAgICctLWNvbnRleHQnLFxuICAgICAgYCR7Q0RLQ29udGV4dEtleS5CQUNLRU5EX05BTUVTUEFDRX09JHtiYWNrZW5kSWQubmFtZXNwYWNlfWAsXG4gICAgICAnLS1jb250ZXh0JyxcbiAgICAgIGAke0NES0NvbnRleHRLZXkuQkFDS0VORF9OQU1FfT0ke2JhY2tlbmRJZC5uYW1lfWBcbiAgICApO1xuXG4gICAgaWYgKGJhY2tlbmRJZC50eXBlICE9PSAnc2FuZGJveCcpIHtcbiAgICAgIGNka0NvbW1hbmRBcmdzLnB1c2goJy0tcmVxdWlyZS1hcHByb3ZhbCcsICduZXZlcicpO1xuICAgIH1cblxuICAgIGNka0NvbW1hbmRBcmdzLnB1c2goXG4gICAgICAnLS1jb250ZXh0JyxcbiAgICAgIGAke0NES0NvbnRleHRLZXkuREVQTE9ZTUVOVF9UWVBFfT0ke2JhY2tlbmRJZC50eXBlfWBcbiAgICApO1xuXG4gICAgaWYgKGFkZGl0aW9uYWxBcmd1bWVudHMpIHtcbiAgICAgIGNka0NvbW1hbmRBcmdzLnB1c2goLi4uYWRkaXRpb25hbEFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZXhlY3V0ZUNvbW1hbmQoY2RrQ29tbWFuZEFyZ3MpO1xuICB9O1xuXG4gIHByaXZhdGUgcG9wdWxhdGVDREtPdXRwdXRGcm9tU3Rkb3V0ID0gYXN5bmMgKFxuICAgIG91dHB1dDogRGVwbG95UmVzdWx0IHwgRGVzdHJveVJlc3VsdCxcbiAgICBzdGRvdXQ6IHN0cmVhbS5SZWFkYWJsZVxuICApID0+IHtcbiAgICBjb25zdCByZWdleFRvdGFsVGltZSA9IC/inKggezJ9VG90YWwgdGltZTogKFxcZCpcXC4qXFxkKilzLiovO1xuICAgIGNvbnN0IHJlZ2V4U3ludGhUaW1lID0gL+KcqCB7Mn1TeW50aGVzaXMgdGltZTogKFxcZCpcXC4qXFxkKilzLztcbiAgICBjb25zdCByZWFkZXIgPSByZWFkbGluZS5jcmVhdGVJbnRlcmZhY2Uoc3Rkb3V0KTtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IGxpbmUgb2YgcmVhZGVyKSB7XG4gICAgICBpZiAobGluZS5pbmNsdWRlcygn4pyoJykpIHtcbiAgICAgICAgLy8gR29vZCBjaGFuY2UgdGhhdCBpdCBjb250YWlucyB0aW1pbmcgaW5mb3JtYXRpb25cbiAgICAgICAgY29uc3QgdG90YWxUaW1lID0gbGluZS5tYXRjaChyZWdleFRvdGFsVGltZSk7XG4gICAgICAgIGlmICh0b3RhbFRpbWUgJiYgdG90YWxUaW1lLmxlbmd0aCA+IDEgJiYgIWlzTmFOKCt0b3RhbFRpbWVbMV0pKSB7XG4gICAgICAgICAgb3V0cHV0LmRlcGxveW1lbnRUaW1lcy50b3RhbFRpbWUgPSArdG90YWxUaW1lWzFdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN5bnRoVGltZSA9IGxpbmUubWF0Y2gocmVnZXhTeW50aFRpbWUpO1xuICAgICAgICBpZiAoc3ludGhUaW1lICYmIHN5bnRoVGltZS5sZW5ndGggPiAxICYmICFpc05hTigrc3ludGhUaW1lWzFdKSkge1xuICAgICAgICAgIG91dHB1dC5kZXBsb3ltZW50VGltZXMuc3ludGhlc2lzVGltZSA9ICtzeW50aFRpbWVbMV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG4iXX0=